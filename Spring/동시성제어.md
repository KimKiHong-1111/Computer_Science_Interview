# 동시성 제어

---

## 동시성 제어(Concurrency Control)
- 데이터 무결성을 보장하기 위해서 사용합니다.
프로세서는 하나의 프로그램 (크롬 창)
- 하나의 컴퓨터 = 하나의 서버 = AWS의 EC2 하나
- 멀티 프로세서 = 여러개의 서버에

스레드는 뭐냐?
하나의 스프링에 여러개의 스레드가 있다.
- 프로세스는 하나의 프로그램, 스레드는 하나의 프로세스 안에서의 작업 단위입니다.
(Spring으로 말하자면 하나의 request에 하나의)

ex)
A라는 데이터가 있을때,

스레드1
A-> B라고 수정
스레드2
A->C
스레드3
A->D

3개의 스레드가 동시에 수행됐을때 A는 무엇으로 바뀔까?? 
정답은 '모른다'이다. 즉, 데이터 무결성을 보장할 수 없다는 뜻이다.

쿠팡에 참치캔 100개가 있을때(동시성 제어가 안되고 있는 상황)
A,B,C 소비자 3명이 동시에 이 참치캔을 1개씩 구매할때,

100 -1*3 -> 97개이어야한다.

그러나 동시성 제어가 안되고 있기때문에 99,98개가 될 수 있다.

실무라면 이용자가 많이 있다고 가정하고 
동시성 문제가 발생할까? 발생하면 괜찮을까? 안괜찮다면 처리를 해줘야겠다.

동시성 제어

배민을 예로들어서,
초창기에 배민을 알리기 위해서,
선착순 1만명 치킨 무료 쿠폰 쏩니다!

치킨 하나에 2만원

1만갠데-> 동시성제어를 잘못해서 3만개 됐어요 -> 동시성 제어를 잘못해서 실수로 2만개가 추가 발행 됐죠 
4억 손해->동시성 제어를 꼭 해야함..

해결방법에 들어가기에 앞서..

동시성 제어 == Lock이 아닙니다.  
동시성 제어를 하는 여러가지 방법 중 하나가 Lock이 있는 것입니다.  
간단히 해보자면, Set 자료구조 같은 것을 활용할 수도 있겠죠.   

하지만, 이번 세션을 Lock위주로 간다.

### 해결 방법?
1) Java 언어의 기능 활용
- 실제로는 사용하지 않으니, 왜 이 방법을 사용하지않는지에 대한 이유만 파악하기!
- synchronized, ReentrantLock
- 스프링 서버가 3개가 있을 때, 자바로 컨트롤 한다는 이야기는 그 중 한개의 스프링 서버에서만 해당하는 이야기.
- 가용성 -> 서버가 터지지 않고 얼마나 잘 유지 될 수 있는가
- 한 서버의 상태가 다른 서버와 동기화 될 수 없으므로, 
2) 트랜잭션 격리 레벨 활용(Transaction Isolation Level) 전체적으로 트랜잭션 격레 레벨을 Serializable로 설정하는건 전체적인 성능저하를 일으킬 수 있다!
- 트랜잭션 default 격리 레벨은 DB마다 다릅니다. // 각 트랜잭션 별 기능은 여기서 상세히 다루지않지만 , 잘 모르신다면 꼭 찾아보시기 바랍니다!

- 1) READ UNCOMMITTED
- 2) READ COMMITED
- 3) REPEATABLE READ 
- 4) SERIALIZABLE설정 하면 동시성 제어가 가능할까요? 가능합니다! 하지만, 단점이 있다.(DB의 성능이 극도로 저하됩니다.)


##### 중간에 용어 정리
- HTTP stateless -> HTTP 요청간의 상태보존이 안된다
- JWT stateless -> 서버가 상태를 갖고 있지 않다(JWT가 갖고 있다)
- 서버 stateless -> 서버는 상태를 가지면 안된다

- 트랙잭션 단위로 isolation을 설정하실 수 있는것 아시나요?
- 
3) DB(+어플리케이션)레벨에서의 Lock제어 
#### 낙관적 락 - 
- 장점 : 
   - 충돌이 드문 경우에 큰 부담 없이 사용가능
- 단점 :
   - 충돌이 드문 경우에  
- 사용 :
    - @version 사용
    - 
#### 비관적 락 - 무슨일이 일어날 것만 같아 (충돌이 자주발생한다고 가정)
- 장점 :
    - 충돌이 드문 경우에
- 단점 :
    - 데드락 발생가능성 있음. 
- 사용 :
    - @Lock(LockModeType.PESSIMISTIC_WRITE) 어노테이션


그러나, 3번 방법을 사용하게 되면 DB와 어플리케이션에 부담이 간다...
성능을 챙기면서도 동시성 제어를 할 수 없을까? 해서 나온 것이 아래의 분산 락
4) 분산 락 (외에 또 다른 3자가 대신 해주죠. 그게 바로 분산)

- 스프링이 DB에 접근하기전에 Redis에게 허락을 받는다.
- 의존성 레디스와 레디슨이 필요
- 분산 환경에서 동일한 자원에 대한 경쟁 조건을 방지하고 데이터의 무결성을 유지하기 위해 사용됩니다. 일반적으로 Redis 등의 외부 시스템을 이용하여 구현합니다.
- 장점 :
    - 여러 노드(서버)에서 공유 자원에 대한 접근을 조율할 수 있다.
    - 분산 시스템에서 데이터 일관성과 무결성을 보장합니다.
- 단점 :
    - 네트워크 지연이나 장애로 인해 락 획득 및 해제의 신뢰성이 문제될 수 있습니다. (결국 redis는 외부 서버이다.)
- 사용 :
    - Rdis(lettuce,Jedis 등)을 이용한 분산 락: SETNX 명령어와 키의 만료 시간을 조합하여 락을 구현합니다.( 너무 귀찮다 . 번거롭다는 단점)
  
    - Redisson 라이브러리 : Redis 기반의 분산 락을 손쉽게 사용할 수 있도록 도와줍니다.
      - FairLock(페어 락)이라는 리스트와 Lua Script(레디스 내부의 언어와 문법)를 활용한 고수준으로 추상화된 기능을 제공.
        루아스크립트 없이, 쌩으로 Redis 3번 호출 400km * 6 = 2400km
        루아스크립트 사용하면 Redis 3번 호출 400km * 3 = 1200km  
    - 분산 락을 AOP화 해서 쓰는 방법 각자 알아보기!
    
--- 

테스트 (코드 그대로 사용하지 않기)
@Data 어노테이션은 쓰지않기.

---

redis를 AOP로 작동하게끔 리팩토링

AOP를 활용한 분산락, 정말 괜찮을까?
함수형 분산락에 대해 공부해보기 //final과제에 이런거 해야해

Jemeter,k6,ngrinder 이런 걸로 분산락 테스트해보는 것도 좋다. 공부해보기.
