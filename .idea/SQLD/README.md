https://www.youtube.com/watch?v=8mlHZVke6h8

SQLD 김강민 최종 정리 1, 2를 듣고 내용을 정리해보았습니다.

# 1과목 데이터모델링의 이해
### DBMS(Databse Management System, 데이터베이스 관리 시스템)의 구조
data - 엄청나게 많은 비정형 data 존재 => 정형data로 전환할 필요-> 표로 정리한다.

Structured data-> 이걸 SQL이라고 부른다.

database(성능은 떨어지지만 용량은 많다)
memory(성능은 좋지만 용량 떨어짐)
데이터를 최대한 효율적으로 다룰 수 있도록 만든 시스템, 그것이 DBMS이다 (ex.Oracle)

CLIENT-SERVER 시스템

OBJECT- 오브젝트는 데이터베이스 내에 존재하는 다양한 유형의 항목
예시.테이블, 뷰, 인덱스 등이 있다.

#### 데이터 모델링 시험빈도 하
"구조적 방법론" - 업무 활동 중심의 방법론으로,'정형화된 절차','도형 중심의 도구'를 사용하여 사용자 요구사항 파악, 문서화하는 기법이다.
"데이터 중심 방법론" -Oracle기반. 데이터에 중심적인 방법론으로 업무 절차, 환경 변화에 매우 유연하다.
"객체 지향 방법론" - 객체를 중심으로 시스템을 분서갛고 설계하는 방식이다.

#### 데이터모델링의 특징(단,추,명) -시험빈도 상
- 단순화(Simplification)
 누구나 쉽게 이해할 수 있도록 표현한다.(지하철 노선도)
- 추상화(Abstraction)<모형과, 가설적>
    현실세계를 간략히 표현한다.
- 명확화(Clartity)
    명확하게 의미가 해석되어야 하고, 한 가지의 의미를 가지며 안된다

#### 데이터모델링 단계별 특징 (3단계로 구분, 개,논,물)
- 개념 데이터 모델링
    가장 높은 수준의 추상화, 포괄적이고 전사적인 모델링
- 논리 데이터 모델링
    정규화, 데이터 표준화를 시행하는 단계, 재사용이 높다.
- 물리 데이터 모델링
    가장 구체적인 모델링이다. 데이터 개체, 속성, 제약 조건 등 전반적으로 정의한다.
    성능, 보안성, 가용성을 고려하여 구축한다.
아래단계로 올수록 구체적이며, 위단계로갈수록 추상적이다.

#### 데이터모델링의 중요성(출제빈도 하) C급 그나마 데이터의 품질쪽 나올 수 있다.
- 파급 효과(Leverage)
시스템이 구축이 완성되어가는 시점에서 데이터 모델을 변경하게 되면 시스템 구축 프로젝트에 큰 위험요소가 된다.
- 간결한 표현(Conciseness)
정보 요구 사항과 한계가 정확하고 간결하게 표현되어야 하므로 데이터 모델이 필요하다.
- 데이터 품질(Data Quality) -그나마 나올가능성
데이터 구조의 문제로 인해 데이터 품질의 문제가 발생한다. 예를 들면 중복데이터의 미정의, 데이터 구조의 비즈니스 정의의 불충분,
동일한 성격의 데이터를 분리하여 데이터 불일치 등이 있다.

#### 데이터 품질과 관련된 유의점 (데이터 품질을 훼손시키는 몇가지 요소들) 중비유일
- 중복(Duplication)
데이터 모델은 같은 데이터를 사용하는 사람, 시간, 그리고 장소를 파악하는데 도움을 준다. 
데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록한다. 
- 비유연성(Inflexibility)
업무가 바뀌었을때 기존의 데이터를 활용못하는 경우
- 비일관성(Inconsistency)
데이터의 중복이 없더라도 비일관성은 발생한다. 데이터들이 서로서로 일치하지않고 일반적이지 않은 데이터를 만들 때, 발생한다.

#### 데이터모델링의 필수요소 (EAR)
1) 업무가 관리하고자하는 복수의 대상(엔티티,Entity)
2) 대상들이 갖는 속성(Attribute)
3) 대상들 간의 관계(Relationship)

### 엔티티
업무에서 저장되고 관리되어야 하는 데이터들의 집합이다.

#### 엔티티의 특징(시험출제빈도 상)
1) 식별여부
엔티티(Entity)는 식별자(Identifier)에 의해서 식별이 가능하다. 엔티티는 유일한 식별자(Unique Identifier)를 필수로 한다.
2) 인스턴스들의 집합
엔티티는 최소 2개 이상의 인스턴스가 존재해야 한다.
3) 속성
엔티티는 반드시 속성(변수)를 가지고 있어야 한다. 각각의 엔티티에는 속성을 2개 이상 갖는다.
하나의 인스턴스는 각각의 속성들에 대해 한 개의 속성 값만을 갖는다.
4) 업무
엔티티는 업무에서 관리되어야 하는 집합이다.
5) 관계
엔티티는 다른 엔티티와 최소한 한 개 이상의 관계를 가진다. (필수로 관계를 가진다!)

#### 엔티티 생성시점에 따른 분류 (생성시점 : 기중행)
- 기본 엔티티(Fundamental Entity) (ex.도서 정보 )
업무에 원래존재하는 정보이다. 
- 중심 엔티티(Main Entity) (ex.주문 행위)
기본 엔티티로부터 발생되고 업무에 있어서 중심적인 역할을 한다.
- 행위 엔티티(Active Entity) (ex.주문 내역, 환불 내역)
두 개 이상의 부모 엔티티로부터 발생되고 내용이 자주 바뀌거나 데이터 양이 증가된다.

#### 엔티티 형태에 따른 분류(형태)
- 유형 엔티티(Tangible Entity)(ex.사원정보 테이블)
물리적 형태가 있는 엔티티이다. 형태가 있으므로 안정적이고 지속적인 특징이 있다.
- 개념 엔티티(Conceptual Entity) (ex.부서정보)
물리적 형태가 없는 엔티티이다. 개념적 정보의 엔티티이다.
- 사건 엔티티(Event Entity)(ex.주문,내역)
업무를 수행함에 따라 발생하는 엔티티이다. 정보의 발생량이 많다는 특징이 있다.

### 속성
업무상 분석해야 하는 대상의 성질,특징을 의미한다.
업무상 인스턴스로 관리하고자 하는 더 이상 분리되지 않는 최소의 데이터 단위이다.

#### 속성의 특성에 따른 분류
- 기본 속성(Basic Attribute)
업무로부터 추출된 모든 속성이다. 엔티티에 가장 일반적이고 많이 존재하는 속성이다.
- 설계 속성(Designed Attribute) (ex.책 분류할때 에세이는 01, 자기개발은 02 등등 번호를 붙히는거)
기본 속성 외, 업무를 규칙화하기 위해 만들어지거나 기존 속성을 변형하여 만들어지는 속성이다.
- 파생 속성(Derived Attribute) (ex.통계,총 수, 총 합 등 )
다른 속성에 영향을 받아 발생하는 속성이다. 보통 계산된 값들이 해당한다.

#### 식별자의 대표성 여부에 따른 분류 (ex.주민번호,직원번호)
- 주 식별자
엔티티 내에서 각 인스턴스들을 구분할 수 있다. 데이터 모델링의 대표성을 지니게 된 식별자
- 보조 식별자 
엔티티 내에서 각 인스턴스들으 구분할 수 있다. 다만, 대표성을 주 식별자들만 타 엔티티에 외부식별자를 생성하여 참조관계를 가진다.
- 내부식별자(직원번호)
엔티티 내부에서 스스로 만들어지는 식별자
- 외부식별자
타 엔티티와의 관계를 통해 타 엔티티로부터 받아오는 식별자

#### 식별자의 속성의 수에 따른 분류
- 단일 식별자
하나의 속성으로 구성된 식별자
- 복합 식별자
둘 이상의 속성으로 구성된 식별자

#### 식별자의 대체 여부에 따른 분류
- 본질 식별자
업무에 의해서 만들어지는 식별자
- 인조 식별자(택배 정보)
업무에 의해서 만들어지지는 않으나, 기존 식별자가 복잡한 구성을 가지고 있어 인위적으로 만들어낸 식별자

### 관계
- 관계명
엔티티의 관점에서 관계가 시작되는 부분을 관계 시작점(The Beginning), 관계를 받는 부분을 관계 끝점(The End)라고 부른다.
- 관계명 기술 규칙
애매한 동사를 피해야 한다.
현재형으로 표현해야 한다.

#### 관계차수(Degree / Cardinality)
1) 1:1 관계 (주민,주민번호)
2) 1:M 관계 (고객, 주문)
3) M:M 관계 (학생, 강의)

#### 식별자관계 / 비식별자 관계
- 식별자 관계(Identifying Relationship)
부모 엔티티의 주식별자(Primary Key)가 자식 엔티티의 식별자로 상속된 경우이다. 
  강한 관계 : 과도한 식별자 관계는 SQL 구분을 복잡하게 하고 오류가능성을 증가시킨다.
- 비식별자 관계(Non-Identifying Relationship)
부모 엔티티의 주식별자가 자식 엔티티의 일반 속성으로 상속된 경우이다.
약한 관계

#### ERD 표기법
1) 엔티티 표기법
I/E 표기법 
Barker 표기법
2) 속성 표기법
3) 식별자 표기법
4) 관계 표기법
5) 관계선택사양 표기법( 시험 자주나옴!!! 그림 꼭 보기)
6) 식별자 / 비식별자 관계 표기법

#### ERD 그리는 순서
1) 엔티티를 그린다.
2) 엔티티를 적절하게 배치한다.
3) 엔티티 간의 관계를 설정한다.
4) 관계명을 기술한다.
5) 관계의 참여도를 기술한다.
6) 관계의 필수 여부를 기술한다.

#### 3단계 스키마 구조(ex.지하철 노선도)

1) 외부(사용자의 관점)
2) 개념(관리자의 관점)
3) 내부 스키마(DB 설계자의 관점)
- 데이터 독립성
서로서로 에게 영향을 미치면안된다.

#### 이상현상 (해소방법 -> 정규화)
1) 삽입이상 - 삽입 시 지정되지 않은 입력값에 null이 저장되는경우
2) 갱신이상 - 갱신할때 일관성이 유지되지 않는 경우
3) 삭제이상 - 불필요한정보 삭제 시 필요한정보까지 삭제되는 현상

#### 정규화
1) 제1 정규화
테이블의 모든 속성은 반드시 하나의 값을 가져야 하고, 테이블의 행들은 (!중요)테이블 속성의 원자성을 확보하고 주식별자를 설정
2) 제2 정규화
제 2 정규화는 주식별자가 2개 이상의 속성으로 이루어진 경우 (!중요)부분 함수적 종속을 제거하는 과정
3) 제3 정규화
엔티티의 일반 속성들 간에는 서로 종속적이지 않는다. 제3정규화는 컬럼 간의 종속성인 이행 함수 종속성을 제거하는 과정.

1과목 끝

# 2과목 SQL기본 및 활용

### SQL 명령어
 SQL - Structured Query Language
 ##### 명령어 구분 문제 나온다!
- DML - SELECT, INSERT, UPDATE, DELETE
- DDL - CREATE, ALTER, DROP, RENAME
- DCL - GRANT, REVOKE
- TCL - COMMIT, ROLLBACK

행(Row,Tuple,Observation)
열(Column,attribute)

### 데이터의 유형
- CHAR(s) : 고정 길이 문자열 정보
- VARCHAR2(s) : 가변 길이 문자열 정보
- NUMBER : 정수, 실수 등 숫자 정보
- DATE : 날짜와 시각 정보

#### SELECT
SELECT 문장을 사용함으로, 원하는 변수와 원하는 행(ROW)을 선택적으로 조회가 가능하다.

#### CONCAT

- [ORACLE]  
    <문자열 혹은 컬럼명> || <문자열 혹은 컬럼명>  

- [SQL SERVER]  
    <문자열 혹은 컬럼명> + <문자열 혹은 컬럼명>  
    CONCAT(<문자열 혹은 컬럼명>,<문자열 혹은 컬럼명>)  
    SELECT 'ABC'||'DEF' FROM EMP; : ABCDEF  
- [DISTINCT]  
    DISTINCT 연산자는 로우 정보들 중에서 중복되는 값을 제거하여 하나만 남기는 집약 기능을 한다.

- [ALIAS 연산자의 사용]
 형태4가지   
  1) SELECT <컬럼명> AS <Alias 컬럼명>  
  2) SELECT <컬럼명> AS "<Alias 컬럼명>"
  3) SELECT <컬럼명> <Alias 컬럼명> -이걸 많이씀.
  4) SELECT <컬럼명> "<Alias 컬럼명>"

** ALIAS는 COLMUN HEADER를 변경하는 기능을 한다.

###### ALIAS- 공백을 포함한 별칭
- 쌍따옴표는 문자열이 공백을 포함하는 경우 쓴다.

#### WHERE
- WHERE 절은 테이블의 각각의 행(개체)에 대해서 개체 조건을 만족하는지 여부를 판단한다.  
    해당 행이 조건을 만족시키면 출력한다. 조건이 '참(TRUE)'이면 출력하고 거짓(FALSE) 이면 출력하지 않는다.
#### 논리 연산자 
##### 연산자 우선순위 (NAO)
1) =,!=,<,>,<=,>=
2) IS NULL, LIKE, BETWEEN, IN, EXISTS
3) NOT
4) AND
5) OR

### SQL 연산자

- BETWEEN <최소값> AND <최대값> : 범위 조건
- IN(<값1>,<값2>) : 여러 개 값들 중 같은 것이 있는 경우 참
- LIKE 연산자  
문자열 칼럼에 저장되어 있는 값이 특정 문자열을 포함하고 있는지 볼 때, LIKE를 사용한다.  
'_' : 특정 미지의 글자 하나를 의미한다.  
'_A_' : (아무거나 1글자 + A + 아무거나 1글자)
   - 
  '%' : 미지의 글자 0개 이상을 의미한다.  
  '%A%' : 앞뒤로 어떤 글자가 와도 상관없다   
- ESCAPE 연산자  
찾고자 하는 와일드카드에 '_','%' 가 포함된 문자를 지정하는 경우 사용
ENAME LIKE 'A_#%' EXCAPE '#'  
: '#' 기호 앞의 '_'는 와일드카드가 아니라 특수문자

### TOP-N 쿼리(가상컬럼)
하나의 테이블에 존재하는 다른 컬럼 값들을 이용해서 만들어진 임시 컬럼  
ORACLE에서 행의 번호를 나타내는 가상 컬럼은 ROWNUM  
SQL SERVER에서 상위 행을 출력하는 함수는 TOP 함수이다.

SELECT<컬럼명>  
FROM<테이블명>  
WHERE <ROWNUM 조건식>


SELECT TOP(<반환할 행의 숫자>)<컬럼 리스트>  
FROM <테이블명>;

### 단일행 함수
SQL에서 기본 제공되는 함수를 내장 함수라 한다.  
단일 행 함수는 하나의 행을 입력했을 때,   결과가 하나의 행으로 나오는 것이다.

- DUAL 테이블

#### 단일행 문자열 함수
- LOWER(<문자열>) : 대문자를 소문자로 바꾸는 함수
- UPPER(<문자열>) : 소문자를 대문자로 바꾸는 함수
- INITCAP(<문자열>) :  첫 글자를 대문자로, 나머지를 소문자로 바꾸는 함수
- CONCAT(<문자열1>,<문자열2>) : 두 개의 문자열을 합쳐서 출력해주는 함수 * 2개만 가능
- LENGTH(<문자열>) : 문자의 개수를 출력해주는 함수
- SUBSTR(<문자열>,<숫자>) : <숫자>번째 글짜를 포함하여 이후의 문자열을 가져온다. * 자주 나오는 중
- SUBSTR(<문자열>,<숫자1>,<숫자2>) : <숫자1> 번쨰 글짜를 포함하여 <숫자1>부터 <숫자2>까지의 문자열을 가져온다. 
- LPAD(<문자열1>,<숫자>,<문자열2>) :  <문자열1>을 출력한 뒤, 남은 <숫자>바이트의 문자열만큼 좌측으로 <문자열2>을 추가한다.
- LPAD(<문자열1>,<숫자>,<문자열2>) :  <문자열1>을 출력한 뒤, 남은 <숫자>바이트의 문자열만큼 우측으로 <문자열2>을 추가한다.
- LTRIM(<문자열1>,<문자열2>) : <문자열1> 좌측에서 부터 <문자열2>가 나타나면 다른 문자가 나올 때까지 제거한다.
- RTRIM(<문자열1>,<문자열2>) : <문자열1> 우측에서 부터 <문자열2> 가 나타나면 다른 문자가 나올 때까지 제거한다.
#### 단일행 날짜 함수(C급)
STSDATE만 알아두기 (연월일 출력가능)

#### CASE 함수
- ► CASE WHEN <조건식1> THEN <반환값1>  
WHEN <조건식2> THEN <반환값2> ...  
END  
<조건식1> 에 만족하면, <반환값1> 을 출력하고,  
<조건식2>에 만족하면, <반환값2>을 출력한다.  


- CASE WHEN <조건식1> THEN <반환값1>  
WHEN <조건식2> THEN <반환값2> ... 
ELSE   
END    
ELSE 절을 사용하는 경우 :
<조건식1> 에 맞는 경우, <조건식2>에 맞는 경우를
제외한 경우 ELSE 의 <반환값> 이 반환된다.
ELSE 절을 사용하지 않는 경우 :
<조건식1> 에 맞는 경우, <조건식2>에 맞는 경우를
제외한 경우 NULL 이 반환된다.
#### DECODE 함수
- DECODE (<컬럼명>, <값1>, <반환값1>,  
<값2>, <반환값2>,  
<값3>, <반환값3>, ... )  
<컬럼명>이 <값1>이면 <반환값1>을 가져오고,  
<값2>이면 <반환값2>를 가져오고 <값3>이면  
<반환값3>를 가져온다.  
<컬럼명> 이 <값1>, <값2>, <값3> 모두 같지 않는  
경우에는 NULL 이 반환된다.  
#### NULL
- 데이터의 값이 알려져 있지 않거나 의미가 없는
  경우에 NULL을 사용한다. 즉, NULL은 값의 부재 혹은
  모르는 값
  NULL 산술연산
  NULL 과의 산술연산은 모두 NULL로 출력된다.
  ►SELECT NULL+2, NULL-2, NULL/2, 2/NULL
  FROM DUAL;
  NULL과의 비교연산 – IS NULL / IS NOT NULL
  ►SELECT EMPNO, COMM FROM EMP WHERE
  COMM IS NULL;
  ►SELECT EMPNO, COMM FROM EMP WHERE
  COMM IS NOT NULL;
  NULL 관련 함수
- NVL(값1,값2) : 값1의 값이 NULL 이면 값2 출력.
- NULLIF(값1,값2) : 값1이 값2와 같으면 NULL을
  아니면 값1을 출력
- COALESCE(값1,값2) : NULL이 아닌 최초의
  표현식, 모두 NULL이면 NULL 반환
  e.g. COALESCE(NULL, NULL, ‘abc’) -> ‘abc’

##### NULL의 특징 (시험 자주 나옴)
1. 기본적인 의미는 값의 부재, 모르는 값을 의미한다.
2. 정렬에서는 무한대의 의미를 가진다. (Oracle) 내림차순하면 맨앞에 나옴
3. 정렬에서는 최소의 값이라는 의미를 가진다. (SQLServer) 내림차순하면 맨 뒤에 나옴
4. NULL/2 , 2/NULL, NULL+NULL, NULL-2 모두
   NULL값으로 출력된다.
5. (SELECT 절에서) NULL = 3 등의 비교연산 시,
   UNKNOWN(알수 없음) 이 반환되어 오류가 발생한다.
   (WHERE 절에서) NULL = 3 등의 비교연산 시,
   UNKNOWN(알수 없음)이 조건절(WHERE)에 들어가서
   거짓(FALSE)의 결과와 같은 결과가 반환된다.

##### ORDER BY (최후에 수행 //정렬은 메모리공간을 많이 잡아먹는다.)
- SELECT 문을 통해 얻어온 결과를 특정 컬럼을 기준으로 오름차순 혹은 내림차순으로 정렬할 수
있다.WHERE, ROWNUM 등과 함께 쓸 수 있다.
숫자, 문자열, 날짜 등 모든 타입의 데이터를 정렬할
수 있다.  
ORDER BY 의 정렬 시점은 모든 실행이 끝난 이후,
데이터 출력 전이다.
ORDER BY 는 데이터 베이스의 메모리를 많이
사용한다. (성능 저하의 요인이 된다.)  
► SELECT <컬럼명> FROM <테이블명>
ORDER BY <컬럼명> [ ASC | DESC ];  
ASC : 오름차순 (생략가능),
DESC : 내림차순

- 컬럼 번호를 이용한 정렬  
►SELECT EMPNO, ENAME, SAL FROM EMP
ORDER BY 3 ASC;  
출력되는 결과의 컬럼의 번호를 기준으로 정렬하는
것이 가능하다.  
하지만, 출력되는 결과의 컬럼 숫자보다 큰 값을
이용하여 정렬하면 오류가 발생한다.

- 출력 되지 않는 컬럼을 이용한 정렬
►SELECT EMPNO,ENAME,DEPTNO
FROM EMP
ORDER BY SAL DESC;  
복수 컬럼을 이용한 정렬  
►SELECT ENAME, SAL,COMM FROM EMP
ORDER BY SAL DESC, ENAME ASC;  
먼저 SAL 내림차순으로 정렬하고 
SAL가 같다면 ENAME 오름차순으로 정렬한다.

###### 정렬의 특징
∙ 숫자, 문자열, 날짜 등 모든 타입의 데이터를 정렬할
수 있다.  
∙ ORDER BY 의 정렬 시점은 모든 조회(SELECT)가
끝난 이후이다  
∙ ORDER BY 는 데이터 베이스의 메모리를 많이
사용한다. (데이터 조회 성능 저하의 요인이 된다.)



#### 집계함수  
► SUM (<컬럼명>) : 컬럼 값들의 총합을 구한다  
► AVG (<컬럼명>) : 컬럼 값들의 평균을 구한다  
► COUNT (<컬럼명>) : 컬럼 값들의 총 개수을  
구한다  
► MAX (<컬럼명>) : 컬럼 값들의 최대값을 구한다  
► MIN (<컬럼명>) : 컬럼 값들의 최소값을 구한다

##### 집계함수와 NULL의 관계
- (원칙) : 집계 함수는 NULL을 제외하고 연산하는 것이
원칙이다.
- (예외) : COUNT(*) 는 행의 수를 센다.(null포함하여 연산)

- 집계함수 WHERE 절에 사용 불가
집계함수는 WHERE 절에 올 수 없다. (집계 함수를
사용할 수 있는 GROUP BY 절보다 WHERE절이 먼저
수행된다. )  

►SELECT EMPNO,ENAME, SAL  
FROM EMP  
WHERE SAL>AVG(SAL) [오류발생]  

집계함수 ORDER BY 절 사용 가능  

► SELECT DEPTNO, MAX(SAL)  
FROM EMP  
GROUP BY DEPTNO  
ORDER BY MAX(SAL);  


#### GROUP BY
데이터들을 기준컬럼에 따라서 원하는 그룹으로 나눌
수 있다.  
개체 속성들은 GROUP BY를 기점으로
그룹수준의 속성들이 된다.  
► GROUP BY <컬럼명>  
► SELECT  
FROM  
WHERE  
GROUP BY <컬럼명>  


HAVING  
그룹수준 속성들의 조건절에 해당


#### GROUP BY NULL  (전체 행들을 하나의 그룹으로 보겠다)


SELECT SUM(SAL)  
FROM EMP  
GROUP BY NULL;  
SELECT SUM(SAL)  
FROM EMP;

#### 그룹함수

ROLLUP (인수 한 개)

###### GROUPING SETS
GROUPING SETS는 각 인수들의 GROUP BY 결과를
합친 결과이다.