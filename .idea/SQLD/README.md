https://www.youtube.com/watch?v=8mlHZVke6h8

SQLD 김강민 최종 정리 1, 2를 듣고 내용을 정리해보았습니다.

# 1과목 데이터모델링의 이해
### DBMS(Databse Management System, 데이터베이스 관리 시스템)의 구조
data - 엄청나게 많은 비정형 data 존재 => 정형data로 전환할 필요-> 표로 정리한다.

Structured data-> 이걸 SQL이라고 부른다.

database(성능은 떨어지지만 용량은 많다)
memory(성능은 좋지만 용량 떨어짐)
데이터를 최대한 효율적으로 다룰 수 있도록 만든 시스템, 그것이 DBMS이다 (ex.Oracle)

CLIENT-SERVER 시스템

OBJECT- 오브젝트는 데이터베이스 내에 존재하는 다양한 유형의 항목
예시.테이블, 뷰, 인덱스 등이 있다.

#### 데이터 모델링 시험빈도 하
"구조적 방법론" - 업무 활동 중심의 방법론으로,'정형화된 절차','도형 중심의 도구'를 사용하여 사용자 요구사항 파악, 문서화하는 기법이다.
"데이터 중심 방법론" -Oracle기반. 데이터에 중심적인 방법론으로 업무 절차, 환경 변화에 매우 유연하다.
"객체 지향 방법론" - 객체를 중심으로 시스템을 분서갛고 설계하는 방식이다.

#### 데이터모델링의 특징(단,추,명) -시험빈도 상
- 단순화(Simplification)
 누구나 쉽게 이해할 수 있도록 표현한다.(지하철 노선도)
- 추상화(Abstraction)<모형과, 가설적>
    현실세계를 간략히 표현한다.
- 명확화(Clartity)
    명확하게 의미가 해석되어야 하고, 한 가지의 의미를 가지며 안된다

#### 데이터모델링 단계별 특징 (3단계로 구분, 개,논,물)
- 개념 데이터 모델링
    가장 높은 수준의 추상화, 포괄적이고 전사적인 모델링
- 논리 데이터 모델링
    정규화, 데이터 표준화를 시행하는 단계, 재사용이 높다.
- 물리 데이터 모델링
    가장 구체적인 모델링이다. 데이터 개체, 속성, 제약 조건 등 전반적으로 정의한다.
    성능, 보안성, 가용성을 고려하여 구축한다.
아래단계로 올수록 구체적이며, 위단계로갈수록 추상적이다.

#### 데이터모델링의 중요성(출제빈도 하) C급 그나마 데이터의 품질쪽 나올 수 있다.
- 파급 효과(Leverage)
시스템이 구축이 완성되어가는 시점에서 데이터 모델을 변경하게 되면 시스템 구축 프로젝트에 큰 위험요소가 된다.
- 간결한 표현(Conciseness)
정보 요구 사항과 한계가 정확하고 간결하게 표현되어야 하므로 데이터 모델이 필요하다.
- 데이터 품질(Data Quality) -그나마 나올가능성
데이터 구조의 문제로 인해 데이터 품질의 문제가 발생한다. 예를 들면 중복데이터의 미정의, 데이터 구조의 비즈니스 정의의 불충분,
동일한 성격의 데이터를 분리하여 데이터 불일치 등이 있다.

#### 데이터 품질과 관련된 유의점 (데이터 품질을 훼손시키는 몇가지 요소들) 중비유일
- 중복(Duplication)
데이터 모델은 같은 데이터를 사용하는 사람, 시간, 그리고 장소를 파악하는데 도움을 준다. 
데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록한다. 
- 비유연성(Inflexibility)
업무가 바뀌었을때 기존의 데이터를 활용못하는 경우
- 비일관성(Inconsistency)
데이터의 중복이 없더라도 비일관성은 발생한다. 데이터들이 서로서로 일치하지않고 일반적이지 않은 데이터를 만들 때, 발생한다.

#### 데이터모델링의 필수요소 (EAR)
1) 업무가 관리하고자하는 복수의 대상(엔티티,Entity)
2) 대상들이 갖는 속성(Attribute)
3) 대상들 간의 관계(Relationship)

### 엔티티
업무에서 저장되고 관리되어야 하는 데이터들의 집합이다.

#### 엔티티의 특징(시험출제빈도 상)
1) 식별여부
엔티티(Entity)는 식별자(Identifier)에 의해서 식별이 가능하다. 엔티티는 유일한 식별자(Unique Identifier)를 필수로 한다.
2) 인스턴스들의 집합
엔티티는 최소 2개 이상의 인스턴스가 존재해야 한다.
3) 속성
엔티티는 반드시 속성(변수)를 가지고 있어야 한다. 각각의 엔티티에는 속성을 2개 이상 갖는다.
하나의 인스턴스는 각각의 속성들에 대해 한 개의 속성 값만을 갖는다.
4) 업무
엔티티는 업무에서 관리되어야 하는 집합이다.
5) 관계
엔티티는 다른 엔티티와 최소한 한 개 이상의 관계를 가진다. (필수로 관계를 가진다!)

#### 엔티티 생성시점에 따른 분류 (생성시점 : 기중행)
- 기본 엔티티(Fundamental Entity) (ex.도서 정보 )
업무에 원래존재하는 정보이다. 
- 중심 엔티티(Main Entity) (ex.주문 행위)
기본 엔티티로부터 발생되고 업무에 있어서 중심적인 역할을 한다.
- 행위 엔티티(Active Entity) (ex.주문 내역, 환불 내역)
두 개 이상의 부모 엔티티로부터 발생되고 내용이 자주 바뀌거나 데이터 양이 증가된다.

#### 엔티티 형태에 따른 분류(형태)
- 유형 엔티티(Tangible Entity)(ex.사원정보 테이블)
물리적 형태가 있는 엔티티이다. 형태가 있으므로 안정적이고 지속적인 특징이 있다.
- 개념 엔티티(Conceptual Entity) (ex.부서정보)
물리적 형태가 없는 엔티티이다. 개념적 정보의 엔티티이다.
- 사건 엔티티(Event Entity)(ex.주문,내역)
업무를 수행함에 따라 발생하는 엔티티이다. 정보의 발생량이 많다는 특징이 있다.

### 속성
업무상 분석해야 하는 대상의 성질,특징을 의미한다.
업무상 인스턴스로 관리하고자 하는 더 이상 분리되지 않는 최소의 데이터 단위이다.

#### 속성의 특성에 따른 분류
- 기본 속성(Basic Attribute)
업무로부터 추출된 모든 속성이다. 엔티티에 가장 일반적이고 많이 존재하는 속성이다.
- 설계 속성(Designed Attribute) (ex.책 분류할때 에세이는 01, 자기개발은 02 등등 번호를 붙히는거)
기본 속성 외, 업무를 규칙화하기 위해 만들어지거나 기존 속성을 변형하여 만들어지는 속성이다.
- 파생 속성(Derived Attribute) (ex.통계,총 수, 총 합 등 )
다른 속성에 영향을 받아 발생하는 속성이다. 보통 계산된 값들이 해당한다.

#### 식별자의 대표성 여부에 따른 분류 (ex.주민번호,직원번호)
- 주 식별자
엔티티 내에서 각 인스턴스들을 구분할 수 있다. 데이터 모델링의 대표성을 지니게 된 식별자
- 보조 식별자 
엔티티 내에서 각 인스턴스들으 구분할 수 있다. 다만, 대표성을 주 식별자들만 타 엔티티에 외부식별자를 생성하여 참조관계를 가진다.
- 내부식별자(직원번호)
엔티티 내부에서 스스로 만들어지는 식별자
- 외부식별자
타 엔티티와의 관계를 통해 타 엔티티로부터 받아오는 식별자

#### 식별자의 속성의 수에 따른 분류
- 단일 식별자
하나의 속성으로 구성된 식별자
- 복합 식별자
둘 이상의 속성으로 구성된 식별자

#### 식별자의 대체 여부에 따른 분류
- 본질 식별자
업무에 의해서 만들어지는 식별자
- 인조 식별자(택배 정보)
업무에 의해서 만들어지지는 않으나, 기존 식별자가 복잡한 구성을 가지고 있어 인위적으로 만들어낸 식별자

### 관계
- 관계명
엔티티의 관점에서 관계가 시작되는 부분을 관계 시작점(The Beginning), 관계를 받는 부분을 관계 끝점(The End)라고 부른다.
- 관계명 기술 규칙
애매한 동사를 피해야 한다.
현재형으로 표현해야 한다.

#### 관계차수(Degree / Cardinality)
1) 1:1 관계 (주민,주민번호)
2) 1:M 관계 (고객, 주문)
3) M:M 관계 (학생, 강의)

#### 식별자관계 / 비식별자 관계
- 식별자 관계(Identifying Relationship)
부모 엔티티의 주식별자(Primary Key)가 자식 엔티티의 식별자로 상속된 경우이다. 
  강한 관계 : 과도한 식별자 관계는 SQL 구분을 복잡하게 하고 오류가능성을 증가시킨다.
- 비식별자 관계(Non-Identifying Relationship)
부모 엔티티의 주식별자가 자식 엔티티의 일반 속성으로 상속된 경우이다.
약한 관계

#### ERD 표기법
1) 엔티티 표기법
I/E 표기법 
Barker 표기법
2) 속성 표기법
3) 식별자 표기법
4) 관계 표기법
5) 관계선택사양 표기법( 시험 자주나옴!!! 그림 꼭 보기)
6) 식별자 / 비식별자 관계 표기법

#### ERD 그리는 순서
1) 엔티티를 그린다.
2) 엔티티를 적절하게 배치한다.
3) 엔티티 간의 관계를 설정한다.
4) 관계명을 기술한다.
5) 관계의 참여도를 기술한다.
6) 관계의 필수 여부를 기술한다.

#### 3단계 스키마 구조(ex.지하철 노선도)

1) 외부(사용자의 관점)
2) 개념(관리자의 관점)
3) 내부 스키마(DB 설계자의 관점)
- 데이터 독립성
서로서로 에게 영향을 미치면안된다.

#### 이상현상 (해소방법 -> 정규화)
1) 삽입이상 - 삽입 시 지정되지 않은 입력값에 null이 저장되는경우
2) 갱신이상 - 갱신할때 일관성이 유지되지 않는 경우
3) 삭제이상 - 불필요한정보 삭제 시 필요한정보까지 삭제되는 현상

#### 정규화
1) 제1 정규화
테이블의 모든 속성은 반드시 하나의 값을 가져야 하고, 테이블의 행들은 (!중요)테이블 속성의 원자성을 확보하고 주식별자를 설정
2) 제2 정규화
제 2 정규화는 주식별자가 2개 이상의 속성으로 이루어진 경우 (!중요)부분 함수적 종속을 제거하는 과정
3) 제3 정규화
엔티티의 일반 속성들 간에는 서로 종속적이지 않는다. 제3정규화는 컬럼 간의 종속성인 이행 함수 종속성을 제거하는 과정.

1과목 끝

# 2과목 SQL기본 및 활용

FROM  
WHERE  
GROUP BY  
HAVING  
SELECT  
ORDER BY  


### SQL 명령어
 SQL - Structured Query Language
 ##### 명령어 구분 문제 나온다!
- DML - SELECT, INSERT, UPDATE, DELETE
- DDL - CREATE, ALTER, DROP, RENAME
- DCL - GRANT, REVOKE
- TCL - COMMIT, ROLLBACK

행(Row,Tuple,Observation)
열(Column,attribute)

### 데이터의 유형
- CHAR(s) : 고정 길이 문자열 정보
- VARCHAR2(s) : 가변 길이 문자열 정보
- NUMBER : 정수, 실수 등 숫자 정보
- DATE : 날짜와 시각 정보

#### SELECT
SELECT 문장을 사용함으로, 원하는 변수와 원하는 행(ROW)을 선택적으로 조회가 가능하다.

#### CONCAT

- [ORACLE]  
    <문자열 혹은 컬럼명> || <문자열 혹은 컬럼명>  

- [SQL SERVER]  
    <문자열 혹은 컬럼명> + <문자열 혹은 컬럼명>  
    CONCAT(<문자열 혹은 컬럼명>,<문자열 혹은 컬럼명>)  
    SELECT 'ABC'||'DEF' FROM EMP; : ABCDEF  
- [DISTINCT]  
    DISTINCT 연산자는 로우 정보들 중에서 중복되는 값을 제거하여 하나만 남기는 집약 기능을 한다.

- [ALIAS 연산자의 사용]
 형태4가지   
  1) SELECT <컬럼명> AS <Alias 컬럼명>  
  2) SELECT <컬럼명> AS "<Alias 컬럼명>"
  3) SELECT <컬럼명> <Alias 컬럼명> -이걸 많이씀.
  4) SELECT <컬럼명> "<Alias 컬럼명>"

** ALIAS는 COLMUN HEADER를 변경하는 기능을 한다.

###### ALIAS- 공백을 포함한 별칭
- 쌍따옴표는 문자열이 공백을 포함하는 경우 쓴다.

#### WHERE
- WHERE 절은 테이블의 각각의 행(개체)에 대해서 개체 조건을 만족하는지 여부를 판단한다.  
    해당 행이 조건을 만족시키면 출력한다. 조건이 '참(TRUE)'이면 출력하고 거짓(FALSE) 이면 출력하지 않는다.
#### 논리 연산자 
##### 연산자 우선순위 (NAO)
1) =,!=,<,>,<=,>=
2) IS NULL, LIKE, BETWEEN, IN, EXISTS
3) NOT
4) AND
5) OR

### SQL 연산자

- BETWEEN <최소값> AND <최대값> : 범위 조건
- IN(<값1>,<값2>) : 여러 개 값들 중 같은 것이 있는 경우 참
- LIKE 연산자  
문자열 칼럼에 저장되어 있는 값이 특정 문자열을 포함하고 있는지 볼 때, LIKE를 사용한다.  
'_' : 특정 미지의 글자 하나를 의미한다.  
'_A_' : (아무거나 1글자 + A + 아무거나 1글자)
   - 
  '%' : 미지의 글자 0개 이상을 의미한다.  
  '%A%' : 앞뒤로 어떤 글자가 와도 상관없다   
- ESCAPE 연산자  
찾고자 하는 와일드카드에 '_','%' 가 포함된 문자를 지정하는 경우 사용
ENAME LIKE 'A_#%' EXCAPE '#'  
: '#' 기호 앞의 '_'는 와일드카드가 아니라 특수문자

### TOP-N 쿼리(가상컬럼)
하나의 테이블에 존재하는 다른 컬럼 값들을 이용해서 만들어진 임시 컬럼  
ORACLE에서 행의 번호를 나타내는 가상 컬럼은 ROWNUM  
SQL SERVER에서 상위 행을 출력하는 함수는 TOP 함수이다.

SELECT<컬럼명>  
FROM<테이블명>  
WHERE <ROWNUM 조건식>


SELECT TOP(<반환할 행의 숫자>)<컬럼 리스트>  
FROM <테이블명>;

### 단일행 함수
SQL에서 기본 제공되는 함수를 내장 함수라 한다.  
단일 행 함수는 하나의 행을 입력했을 때,   결과가 하나의 행으로 나오는 것이다.

- DUAL 테이블

#### 단일행 문자열 함수
- LOWER(<문자열>) : 대문자를 소문자로 바꾸는 함수
- UPPER(<문자열>) : 소문자를 대문자로 바꾸는 함수
- INITCAP(<문자열>) :  첫 글자를 대문자로, 나머지를 소문자로 바꾸는 함수
- CONCAT(<문자열1>,<문자열2>) : 두 개의 문자열을 합쳐서 출력해주는 함수 * 2개만 가능
- LENGTH(<문자열>) : 문자의 개수를 출력해주는 함수
- SUBSTR(<문자열>,<숫자>) : <숫자>번째 글짜를 포함하여 이후의 문자열을 가져온다. * 자주 나오는 중
- SUBSTR(<문자열>,<숫자1>,<숫자2>) : <숫자1> 번쨰 글짜를 포함하여 <숫자1>부터 <숫자2>까지의 문자열을 가져온다. 
- LPAD(<문자열1>,<숫자>,<문자열2>) :  <문자열1>을 출력한 뒤, 남은 <숫자>바이트의 문자열만큼 좌측으로 <문자열2>을 추가한다.
- LPAD(<문자열1>,<숫자>,<문자열2>) :  <문자열1>을 출력한 뒤, 남은 <숫자>바이트의 문자열만큼 우측으로 <문자열2>을 추가한다.
- LTRIM(<문자열1>,<문자열2>) : <문자열1> 좌측에서 부터 <문자열2>가 나타나면 다른 문자가 나올 때까지 제거한다.
- RTRIM(<문자열1>,<문자열2>) : <문자열1> 우측에서 부터 <문자열2> 가 나타나면 다른 문자가 나올 때까지 제거한다.
#### 단일행 날짜 함수(C급)
STSDATE만 알아두기 (연월일 출력가능)

#### CASE 함수
- ► CASE WHEN <조건식1> THEN <반환값1>  
WHEN <조건식2> THEN <반환값2> ...  
END  
<조건식1> 에 만족하면, <반환값1> 을 출력하고,  
<조건식2>에 만족하면, <반환값2>을 출력한다.  


- CASE WHEN <조건식1> THEN <반환값1>  
WHEN <조건식2> THEN <반환값2> ... 
ELSE   
END    
ELSE 절을 사용하는 경우 :
<조건식1> 에 맞는 경우, <조건식2>에 맞는 경우를
제외한 경우 ELSE 의 <반환값> 이 반환된다.
ELSE 절을 사용하지 않는 경우 :
<조건식1> 에 맞는 경우, <조건식2>에 맞는 경우를
제외한 경우 NULL 이 반환된다.
#### DECODE 함수
- DECODE (<컬럼명>, <값1>, <반환값1>,  
<값2>, <반환값2>,  
<값3>, <반환값3>, ... )  
<컬럼명>이 <값1>이면 <반환값1>을 가져오고,  
<값2>이면 <반환값2>를 가져오고 <값3>이면  
<반환값3>를 가져온다.  
<컬럼명> 이 <값1>, <값2>, <값3> 모두 같지 않는  
경우에는 NULL 이 반환된다.  
#### NULL
- 데이터의 값이 알려져 있지 않거나 의미가 없는
  경우에 NULL을 사용한다. 즉, NULL은 값의 부재 혹은
  모르는 값
  NULL 산술연산
  NULL 과의 산술연산은 모두 NULL로 출력된다.
  ►SELECT NULL+2, NULL-2, NULL/2, 2/NULL
  FROM DUAL;
  NULL과의 비교연산 – IS NULL / IS NOT NULL
  ►SELECT EMPNO, COMM FROM EMP WHERE
  COMM IS NULL;
  ►SELECT EMPNO, COMM FROM EMP WHERE
  COMM IS NOT NULL;
  NULL 관련 함수
- NVL(값1,값2) : 값1의 값이 NULL 이면 값2 출력.
- NULLIF(값1,값2) : 값1이 값2와 같으면 NULL을
  아니면 값1을 출력
- COALESCE(값1,값2) : NULL이 아닌 최초의
  표현식, 모두 NULL이면 NULL 반환
  e.g. COALESCE(NULL, NULL, ‘abc’) -> ‘abc’

##### NULL의 특징 (시험 자주 나옴)
1. 기본적인 의미는 값의 부재, 모르는 값을 의미한다.
2. 정렬에서는 무한대의 의미를 가진다. (Oracle) 내림차순하면 맨앞에 나옴
3. 정렬에서는 최소의 값이라는 의미를 가진다. (SQLServer) 내림차순하면 맨 뒤에 나옴
4. NULL/2 , 2/NULL, NULL+NULL, NULL-2 모두
   NULL값으로 출력된다.
5. (SELECT 절에서) NULL = 3 등의 비교연산 시,
   UNKNOWN(알수 없음) 이 반환되어 오류가 발생한다.
   (WHERE 절에서) NULL = 3 등의 비교연산 시,
   UNKNOWN(알수 없음)이 조건절(WHERE)에 들어가서
   거짓(FALSE)의 결과와 같은 결과가 반환된다.

##### ORDER BY (최후에 수행 //정렬은 메모리공간을 많이 잡아먹는다.)
- SELECT 문을 통해 얻어온 결과를 특정 컬럼을 기준으로 오름차순 혹은 내림차순으로 정렬할 수
있다.WHERE, ROWNUM 등과 함께 쓸 수 있다.
숫자, 문자열, 날짜 등 모든 타입의 데이터를 정렬할
수 있다.  
ORDER BY 의 정렬 시점은 모든 실행이 끝난 이후,
데이터 출력 전이다.
ORDER BY 는 데이터 베이스의 메모리를 많이
사용한다. (성능 저하의 요인이 된다.)  
► SELECT <컬럼명> FROM <테이블명>
ORDER BY <컬럼명> [ ASC | DESC ];  
ASC : 오름차순 (생략가능),
DESC : 내림차순

- 컬럼 번호를 이용한 정렬  
►SELECT EMPNO, ENAME, SAL FROM EMP
ORDER BY 3 ASC;  
출력되는 결과의 컬럼의 번호를 기준으로 정렬하는
것이 가능하다.  
하지만, 출력되는 결과의 컬럼 숫자보다 큰 값을
이용하여 정렬하면 오류가 발생한다.

- 출력 되지 않는 컬럼을 이용한 정렬
►SELECT EMPNO,ENAME,DEPTNO
FROM EMP
ORDER BY SAL DESC;  
복수 컬럼을 이용한 정렬  
►SELECT ENAME, SAL,COMM FROM EMP
ORDER BY SAL DESC, ENAME ASC;  
먼저 SAL 내림차순으로 정렬하고 
SAL가 같다면 ENAME 오름차순으로 정렬한다.

###### 정렬의 특징
∙ 숫자, 문자열, 날짜 등 모든 타입의 데이터를 정렬할
수 있다.  
∙ ORDER BY 의 정렬 시점은 모든 조회(SELECT)가
끝난 이후이다  
∙ ORDER BY 는 데이터 베이스의 메모리를 많이
사용한다. (데이터 조회 성능 저하의 요인이 된다.)



#### 집계함수  
► SUM (<컬럼명>) : 컬럼 값들의 총합을 구한다  
► AVG (<컬럼명>) : 컬럼 값들의 평균을 구한다  
► COUNT (<컬럼명>) : 컬럼 값들의 총 개수을  
구한다  
► MAX (<컬럼명>) : 컬럼 값들의 최대값을 구한다  
► MIN (<컬럼명>) : 컬럼 값들의 최소값을 구한다

##### 집계함수와 NULL의 관계
- (원칙) : 집계 함수는 NULL을 제외하고 연산하는 것이
원칙이다.
- (예외) : COUNT(*) 는 행의 수를 센다.(null포함하여 연산)

- 집계함수 WHERE 절에 사용 불가
집계함수는 WHERE 절에 올 수 없다. (집계 함수를
사용할 수 있는 GROUP BY 절보다 WHERE절이 먼저
수행된다. )  

►SELECT EMPNO,ENAME, SAL  
FROM EMP  
WHERE SAL>AVG(SAL) [오류발생]  

집계함수 ORDER BY 절 사용 가능  

► SELECT DEPTNO, MAX(SAL)  
FROM EMP  
GROUP BY DEPTNO  
ORDER BY MAX(SAL);  


#### GROUP BY
데이터들을 기준컬럼에 따라서 원하는 그룹으로 나눌
수 있다.  
개체 속성들은 GROUP BY를 기점으로
그룹수준의 속성들이 된다.  
► GROUP BY <컬럼명>  
► SELECT  
FROM  
WHERE  
GROUP BY <컬럼명>  


HAVING  
그룹수준 속성들의 조건절에 해당


#### GROUP BY NULL  (전체 행들을 하나의 그룹으로 보겠다)


SELECT SUM(SAL)  
FROM EMP  
GROUP BY NULL;  
SELECT SUM(SAL)  
FROM EMP;

#### 그룹함수

ROLLUP (인수 한 개)

###### GROUPING SETS
GROUPING SETS는 각 인수들의 GROUP BY 결과를
합친 결과이다.

###### ROLLUP : 인수가 두 개 이상인 경우
ROLLUP(A,B) 로 인수가 두개인 경우에는 ROLLUP의
결과값을 다음과 같이 구할 수 있다.  
ROLLUP(A,B) = GROUPING SETS((A,B))+ GROUPINGS
SETS(A) + GROUPING SETS(NULL)

###### 정리 : 그룹함수 인수 2개인 경우

###### GROUP BY 그룹함수 (A,B)

ROLLUP : GROUP BY A,B + GROUP BY A + GROUP
BY NULL  
CUBE : GROUP BY A,B + GROUP BY A + GROUP BY
B + GROUP BY NULL  
GROUPING SETS : GROUP BY A + GROUP BY B  

###### 그룹함수의 특징
###### ROLLUP :   
ROLLUP의 인수는 계층구조이므로 인수
순서가 바뀌면 수행 결과도 바뀐다.  
ROLLUP(DEPTNO,MGR) ≠ ROLLUP(MGR,DEPTNO)
###### CUBE :   
다차원 집계 함수이므로, 시스템 부하가
ROLLUP 보다 크다  
CUBE의 인수들은 평등한 관계이므로, 순서는
무관하다. (CUBE(DEPTNO,MGR) = CUBE(MGR,
DEPTNO))  
###### GROUPING SETS :   
GROUPING SETS의 인수들은
평등한 관계이므로, 순서는 무관하다. (GROUPING
SETS(DEPTNO,MGR) = GROUPING SETS(MGR,
DEPTNO))
###### 윈도우 함수  
개별 데이터들에 대한 연산 결과를 출력해주는 분석
함수(Analytical Function)

###### PARTITION BY :   
GROUP BY 와 비슷한 역할,
기준컬럼에 따라서 윈도우 함수 처리 범위를 모으는
역할
###### ORDER BY :   
정렬작업으로 행과 행간의 관계를
정의해주는 역할
###### WINDOWING 절 :   
값의 처리 범위를 정의

###### 집계함수
► <집계함수> (<집계 대상 컬럼명>) OVER (PARTITION BY
<집계할 대상의 범위> ORDER BY <정렬 기준 컬럼 >
ROWS <행의 수> PRECEDING)  
► <집계함수> (<집계 대상 컬럼명>) OVER (PARTITION BY
<집계할 대상의 범위> ORDER BY <정렬 기준 컬럼 >
ROWS BETWEEN <행의 수1> AND <행의 수2>)  
► <집계함수> (<집계 대상 컬럼명>) OVER (PARTITION BY
<집계할 대상의 범위> ORDER BY <정렬 기준 컬럼 >
RANGE <값> PRECEDING)  
► <집계함수> (<집계 대상 컬럼명>) OVER (PARTITION BY
<집계할 대상의 범위> ORDER BY <정렬 기준 컬럼 >
RANGE BETWEEN <값1> AND <값2> )

###### 행 순서 함수
- FIRST_VALUE (<값>) : 윈도우에서 가장 처음에 나오는
값을 구한다.
- LAST_VALUE (<값>) : 윈도우에서 가장 나중에 나오는
값을 구한다.
- LAG (<값>, <숫자1>, <숫자2>) : 파티션에서 <값>에
대하여 현재행 이전 <숫자1>행의 값을 구한다. 그
값이 없다면 <숫자2>를 반환한다.
- LEAD (<값>, <숫자1>, <숫자2>) :파티션에서 <값> 에
대하여 현재행 이후 <숫자1>행의 값을 구한다. 그
값이 없다면 <숫자2>를 반환한다.

###### 비율 관련 함수
- RATIO_TO_REPORT : 파티션 내 전체 SUM(컬럼)값에
대한 행별 칼럼 값의 백분율을 소수점으로 구할 수
있다.  
- CUME_DIST : 파티션 전체 건수에서 동일한 할당을
나누었을때, 누적 백분율을 조회한다. (누적 분포상
위치를 0~1사이 값을 가진다.)  
- PERCENT_RANK : 파티션에 제일 먼저 나온 것을
0으로 제일 늦게 나온 것을 1로 하여, 값이 아닌 행의
순서별 위치 백분율을 조회한다. <중위값, Q1,Q2,Q3>  
- NTILE(n) : 파티션 별로 N등분하여 조를 나눈다. 이때
나머지는 상위 조에게 순서대로 배정되게 한다.

###### CROSS JOIN
조건 없이 2개의 테이블을 하나로 조인하는 것이다.
카테시안 곱(Cartesian Product)이 발생한다.  
.  
SELECT A.EMPNO , A.ENAME , B.DEPTNO ,
B.DNAME
FROM EMP A , DEPT B
WHERE B.DEPTNO = A.DEPTNO ;

  
SELECT A.EMPNO , A.ENAME , B.DEPTNO ,
B.DNAME
FROM EMP A JOIN DEPT B
ON B.DEPTNO = A.DEPTNO ;  


###### NATURAL JOIN의 특징
1. USING, ON, WHERE 절로 조인 조건 절을 서술할
   필요가 없다.
2. 공통 컬럼을 자동적으로 찾아서 조인한다.
3. OUTER JOIN 에서도 사용 가능하다. 


###### 외부조인 (OUTER JOIN)
   OUTER JOIN은 선행 테이블(좌측 테이블) 혹은 후행
   테이블(우측 테이블)을 기준으로 조인 조건에
   만족하지 않는 행들을 포함하여 출력한다.  
   LEFT JOIN  
   ▶SELECT  
   FROM <테이블 명 1> LEFT OUTER JOIN <테이블 명
   2> ON <조인 조건식>  
   ▶SELECT  
   FROM <테이블 명 1> LEFT OUTER JOIN <테이블 명
   2> ON <조인 조건식>  

###### LEFT JOIN
▶SELECT  
FROM <테이블 명 1> LEFT OUTER JOIN <테이블 명
2> ON <조인 조건식>  
▶SELECT  
FROM <테이블 명 1> LEFT OUTER JOIN <테이블 명
2> ON <조인 조건식>

###### RIGHT JOIN
▶SELECT  
FROM <테이블 명 1> RIGHT OUTER JOIN <테이블
명 2> ON <조인 조건식>  
▶SELECT  
FROM <테이블 명 1>,<테이블 명 2>
WHERE <테이블 명1 컬럼> (+) = <테이블명2 컬럼>
셀프조인(SELF JOIN)

부모노드에서 부터 자식노드까지 데이터들을 전개하는
것을 순방향 전개라고 한다.  
셀프 조인에서는 두개 이상의 동일한 테이블을
이용해서 조인이 이루어지는데, 동일 테이블 각각의
역할이 다르다  
###### 계층형 질의  
부모와 자식, 상사와 부하와 같은 구조를 계층형
구조라고 부른다. ORACLE에서는 이러한 계층형
데이터를 분석하기 위한 기능을 제공한다. 이를
계층형 질의라고 한다.  
※ 계층형 질의는 SQL SERVER에서 지원하지 않는다  


► SELECT EMPNO, ENAME, MGR,  
CONNECT_BY_ISLEAF, LEVEL    
FROM EMP    
WHERE <조건절>    
START WITH MGR IS NULL    
CONNECT BY PRIOR EMPNO=MGR;  

START WITH : 계층 구조 전개의 시작위치 (루트
데이터, 부모 데이터의 정보)  
CONNECT BY : 다음에 전개될 자식데이터를 지정한다.  
계층형 전개의 조건식으로, 자식 데이터는 CONNECT
BY 절에 주어진 조건을 만족해야 한다.  
PRIOR : CONNECT BY 절에 사용되며, 이전 레벨
데이터를 지칭할 때 쓴다.
WHERE : 모든 전개 수행 후에, 지정된 조건을
만족하는 데이터만을 추출한다. ※ 계층 데이터 형성
후 가장 마지막에 적용되는 조건이다.  
CONNECT BY PRIOR 자식컬럼 = 부모컬럼 
부모에서 자식으로 트리 그리기 : 순방향 전개
###### 가상컬럼  
LEVEL : 루트 데이터면 1 하위 데이터이면 2이다.
리프(Leaf) 데이터까지 1씩 증가한다.  
CONNECT_BY_ISLEAF : 전개 과정에서 해당 데이터가
리프 데이터이면 1, 그렇지 않으면 0이다.  
SYS_CONNECT_BY_PATH(<컬럼명>, ‘<경로분리자>’) :
루트 데이터부터 현재 전개할 데이터까지의 경로를
표시한다.  
CONNECT_BY_ROOT(<컬럼명>) : 현재 전개할
데이터의 루트 데이터를 표시한다.  
※ CONNECT_BY_ROOT 에서 최상위 관리자 본인의
이름도 등장한다.  
###### 서브쿼리
쿼리문(메인쿼리) 안에 들어가는 쿼리문(서브쿼리)
쿼리문 작성시 사용되는 값을 다른 쿼리에서 구해야
할 경우 사용한다.  
###### 반환 결과에 따른 서브쿼리 분류

###### INLINE VIEW (인라인뷰)
FROM 구에 SELECT문을 사용하여 가상의 테이블을
만드는 효과가 있다.  
###### 상호연관 서브쿼리  
SELECT A.ENAME, A.SAL, A.DEPTNO
FROM EMP A  
WHERE A.SAL > (SELECT AVG(B.SAL)
FROM EMP B  
WHERE A.DEPTNO = B.DEPTNO);  
###### 다중행 서브쿼리 연산자  
IN : 서브쿼리의 결과 중 하나라도 일치하면 조건은
TRUE  
ANY,SOME : 서브쿼리의 결과와 하나이상 일치하면
조건은 TRUE  
ALL : 서브쿼리의 결과와 모두 일치해야 조건이
참이된다.  
EXISTS : 데이터의 존재 여부를 확인하는 쿼리에
해당한다. (만족하는 값이 없으면 공집합을 반환)  

###### 집합연산자 (수직결합)
UNION : 합집합 <중복된 것 배제, 정렬의 의미를
포함>  
UNION ALL : 합집합, 중복된 데이터를 모두 가져온다.
<정렬 없음>  
INTERSECT : 교집합 <중복된 것 배제>  
MINUS : 차집합 <MS SQL에서는 EXCEPT>, <중복된
것 배제>


###### 테이블명, 컬럼명 명명 규칙
- 테이블명과 칼럼명은 반드시 문자로 시작해야한다.
- A-Z,a-z,0-9,
- 특수문자는 _, $, #만 사용 가능

###### 제약조건
목적 : 데이터의 무결성 유지   
UNIQUE KEY(고유키) : 고유키 정의  
NOT NULL : NULL 값 입력금지  
PRIMARY KEY(기본키) : UNIQUE & NOT NULL  
CHECK : 입력 값 범위 제한  
FOREIGN KEY(외래키) : NULL 가능,

###### 테이블 생성
CREATE TABLE 테이블명 (컬럼명 데이터유형
제약조건);
테이블 구조 변경
- 컬럼 추가 : ALTER TABLE 테이블명 ADD(컬럼명
  데이터유형);
- 삭제 : ALTER TABLE 테이블명 DROP COLUMN
  컬럼명;
- 수정 : ALTER TABLE 테이블명 MODIFY
  (컬럼명 데이터유형 제약조건);  
  제약조건 삭제 : DROP CONSTRAINT 제약조건명;  
  제약조건 추가 : ADD CONSTRAINT 제약조건명 조건  
  테이블명 변경 : RENAME 변경전 테이블명 TO  
  변경후 테이블명;  
  테이블 삭제 : DROP TABLE 테이블명;  
  테이블 데이터 삭제 : TRUNCATE TABLE 테이블명;  
  컬럼명 변경 : RENAME COLUMN 변경전 컬럼명 TO  
  변경 후 컬럼명

###### INSERT
INSERT INTO TABLE (<컬럼명1>,<컬럼명2>,...)  
VALUES(<값1>,<값2>,...);  
VALUES의 로우 정보값  
i) 문자열일 경우, ‘’ 를 붙여서 입력  
ii) 숫자일 경우, ‘’ 없이 입력  
1. 데이터의 추가  
   INSERT INTO EXAMPLE (EMPNO,ENAME,JOB)  
   VALUES(1000,’김강민’,’인사’);  
2. 컬럼목록을 생략하는 경우 데이터의 추가  
   INSERT INTO EXAMPLE  
   VALUES(1001, ‘이성우’ ,’영업’);  
3. 컬럼 목록에 모든 컬럼이 있지 않는 경우  
   INSERT INTO EXAMPLE (EMPNO,ENAME)  
   VALUES(1002,’김영희’);  

###### UPDATE
UPDATE <테이블명>  
SET <컬럼1>=<값1>, ...  
WHERE <조건문>;  
###### DELETE  
DELETE FROM <테이블명>  
WHERE <조건절>;  
###### TCL
COMMIT : 트랜잭션을 완료하고 디스크에 반영한다.  
COMMIT 후, 복구는 불가하다.  
ROLLBACK : 트랜잭션을 취소한다. 마지막 COMMIT
지점으로 돌아간다.  
SAVEPOINT : ROLLBACK시 돌아가는 저장포인트를
지정한다. (세이브포인트 동일이름 지정시 덮여쓰기
됨)

###### ORACLE COMMIT
- DML(INSERT, UPDATE, DELETE) 는 사용자가 반드시
  커밋 해주어야 데이터베이스에 반영된다.
- DDL(CREATE, ALTER, DROP, TRUNCATE) 는 사용시
  자동적으로 커밋이 이루어진다.
###### SQL SERVER COMMIT
- AUTO COMMIT OFF : DML, DDL 모두 커밋 요함
- AUTO COMMIT ON : DML, DDL 모두 자동 커밋
###### DELETE VS TRUNCATE
  DELETE : ROLLBACK 으로 복구 가능  
  TRUNCATE : 시스템 활용의 측면에서 TRUNCATE
  시스템 부하가 적음  

###### 트랜잭션의 특성
  원자성 : 트랜잭션에서 정의된 연산들은 모두
  성공적으로 실행되던지 아니면 전혀 실행되지 않은
  상태로 남아있어야 한다.  
  고립성 : 트랜잭션이 실행되는 도중에 다른
  트랜잭션의 영향을 받아 잘못된 결과를 만들어서는
  안된다.  
  지속성 : 트랜잭션이 성공적으로 수행되면 그
  트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로
  저장된다.  
  일관성 : 트랜잭션이 실행되기 전의 데이터베이스
  내용이 잘못 되어있지 않다면 트랜잭션이 실행된
  이후에도 일관성 있는 데이터베이스를 유지한다.  


###### DCL
GRANT : 데이터베이스 사용자에게 권한을 부여하는
것이다. 데이터베이스의 사용을 위해 데이터의
연결,수정,입력,삭제,조회 등을 하게 해준다.  

REVOKE : 데이터베이스 사용자에게 부여된 권한을
회수한다.  
GRANT <권한명> ON <객체명> TO <유저명>  
REVOKE <권한명> ON <객체명> FROM <유저명>  

###### ROLE
사용자에게 허가할 수 있는 권한들의 집합  
ROLE을 이용하면 권한 부여와 회수를 쉽게 할 수
있다.  
ROLE은 CREATE ROLE 권한을 가진 USER에 의해
생성된다.  
한 사용자가 여러 개의 ROLE을 가질 수 있고, 여러
사용자에게 동일한 ROLE을 부여할 수 있다.  
GRANT 와 REVOKE로 사용자에게 ROLE을 부여하고
취소도 가능하다.  
사용자는 ROLE에 ROLE을 부여하는 것도 가능하다.  

###### 뷰(VIEW)
뷰는 데이터베이스에서 제공하는 가상의 테이블을
의미한다.  
뷰를 사용하면 복잡한 쿼리문을 대신할 수 있기
때문에 개발의 용이성을 가진다.  
뷰는 뷰를 만들 때 사용한 쿼리문을 저장하는 것이며,
뷰를 조회할 때는 뷰를 만들 때 사용한 쿼리문이
동작한다.

###### 이론상 뷰의 장점(빈출) <독.편.보>
독립성 : 테이블 구조가 변경되어도 뷰를 사용하는
응용프로그램은 변경하지 않아도 된다.
편리성 : 복잡한 질의를 뷰로 생성함으로서 관련
질의를 단순하게 작성할 수 있다.
보안성 :숨기고 싶은 정보가 있다면 뷰를 생성할 시에
해당 컬럼을 빼고 생성하여 사용자에게 정보를 감출
수 있다.