# 캐시

2. Memory캐시
3. 캐시전략(Caching Stratgies)과 정책
   1) 캐시 적중/미스
    - Cache Hit
    - 사용자가 요청한
    - Cache Miss
    - 요청한 데이터가 캐시에 없을 경우를 의미.
    - 이때는 원본 저장소(데이터베이스, API, 파일 등) 에서 데이터를 가져오고, 일반적으로 캐시에 저장 한 뒤 반환함.
    - Cold Miss(콜드 미스) : 
    - 캐시에 처음 저장하는 경우,
    - 서버 시작 직후, 혹은 새로운 키 요청 시 주로 발생.
---
    - Capacity Miss(용량 미스) :
    - 캐시 공간이 부족해 오래된 데이터가 제거 된 뒤 다시 해당 데이터가 요청됨
---
    - Expiration Miss(만료 미스) : 
    - TTL이 지나 데이터가 만료된 뒤 다시 요청될 때.
    - ex)사용자가

첫 사용자 경험이 다소 느릴 수 있음(콜드 스타트 문제)

- Hit Ratio 설명
- 캐시가 얼마나 효율적으로 동작하고 있는지를 보여주는 지표.
- 계산 공식 -> Hit Ratio = (Number of Cache Hits) / (Total Requests)
- 높은 적중률이 꼭 좋은 건 아님. 비효율적인 데이터를 캐싱하고 있으면 낭비임.

## 2) 캐시 무효화(Invalidation) 전략
-> 캐시에 저장된 데이터가 더 이상 유효하지 않을 때, 캐시에서 삭제하거나 갱신하는 전략
 - 데이터는 변화하지만, 캐시는 한번 저장되면 변하지않음
 - 그렇기 떄문에 캐시와 실제 데이터(DB,API) 사이에 불일치(Inconsistency) 문제가 발생할 수 있음
-> 실무에서 자주 쓰는 캐시 무효화 전략
 - TTL(Time To Live)
     - df캐시에 데이터를 저장할 때, 일정 시간 이후 자동으로 만료되도록 설정함.
     - 게시판 목록, 인기글, 날씨 정보처럼 짧은 시간 내 자주 바뀌지 않는 데이터에 사용
     - 예 : user:1234 프로필 캐시->TTL:10분
        - 유저가 프로필 변경하면
- LRU(Least Recently Used)
    - 가장 오랫동안 사용되지 않은 데이터를 제거
    - "최근에 사용된 데이터는 앞으로도 사용될 가능성이 높다"는 가정
    - 구현 쉬움(LinkedHashMAp, Deque로도 가능)
    - 
        
- LFU(Least Frequently Used)
    - 가장 사용 횟수가 적은 데이터를 제거한다.
    - "자주 사용하는 데이터는 앞으로도 자주 쓰일 것이다"는 가정
    - 데이터마다 접근 횟수를 기록하고, 그 수가 가장 낮은 항목을 제거
    - 각 키에 접근할 때마다 count 증가
    - 캐시가 가득차면, 가장 count가 낮은 키부터 제거
    - 추천 알고리즘
- FIFO(First In First Out)
    - 가장 먼저 들어온 데이터를 제거한다.
    - 데이터가 들어온 순서만 고려함
    - 큐(Queue)처럼 동작
    - 빠르게 회전하는 데이터에서 사용
    - 구현이 매우 단순
    - 별도의 접근 기록 필요없음 -> 가볍다
    - 자주 쓰는 데이터

3) 캐시 전략
- Look-Aside
    - 데이터를 찾을 때 우선 캐시에서 데이터를 찾고 데이터가 있다면 캐시에서 데이터를 가지고 오는 전략
    - 만약 캐시에 데이터가 없어 Cache Miss가 발생한다면 앱은 DB에서 데이터를 가져온 뒤 캐시에 넣어주는 작업을 함
    - 캐시에 찾는 데이터가 없을 때 DB에 직접 조회해서 입력되기 떄문에 Lazy Loading
    - 이 구조는 캐시가 다운되더라도 DB에서 데이터를 가지고 올 수 있음
    - 만약 레디스가 다운되거나 DB에만 새로운 데이터가 있다면 Cache Miss로 인해서
- Write-Through
    - 데이터를 저장할 때 먼저 캐시에 저장한 다음 DB에 저장하는 방식
    - 캐시는 항상 최신
- Write-Back
    - Write Back은 먼저 캐시에 데이터를 저장했다가 특정 시점마다 DB에 저장하는 방식
    - 캐시에 데이터를 모았다가 한 번에 DB에 저장하기 때문에 DB 쓰기 비용을 절약할 수 있지만 데이터를 옮기기 전에 캐시 장애가 발생하면 데이터 유실이 발생
- Write-Around
    - Write Around는 모든 데이터는 DB에 저장되고 읽은 데이터만 캐시에 저장되는 방식

4) 실무 관점으로 본 일관성과 동기화
- Stale data 문제
    - 캐시에 저장된 데이터가 원본 데이터와 다르게 오래된 상태
    - ex) 유저가 프로필 사진을 변경했는데, 캐시에 이전 이미지가 남아있어 여전히 옛날 사진이 보임, 상품 가격을 변경했는데,캐시된 데이터엔 이전 가격이 계속 노출됨 -> '캐시 지우고 다시 해봐'
    - 이에 실무에서는 아래와 같은 문제로 여김
        - 일관성 붕괴 : 유저 경험 혼란
        - 신뢰도 하락 : 관리자가 바꿨느네도 사용자 화면에는 반영 안됨
        - 특히 금전, 보안 관련 정보에선느 심각한 오류로 이어질 수 있음!! 서비스 문닫는 거임
      
    - 캐시 갱신 타이밍
        - 원본 데이터가 변경됐을 때, 언제, 어떻게 캐시를 갱신할 것인가를 결정하는 전략
        - 실무에서는
            - 게시글 수정 시:
                - post:1234 캐시 -> DB 저장 후 즉시 삭제(redisTemplate.delete(...)) 
### 4. 실무적용 예시

- DB 부하 감소
- 응답 속도 향상(Redis는 메모리 기반이라 빠름)
- 캐시 무효화 전략(예: TTL, 수동 삭제)을 반드시 고민해야 함
- Redis 장애 시


- CDN (Cloudflare, AWS CloudFront)