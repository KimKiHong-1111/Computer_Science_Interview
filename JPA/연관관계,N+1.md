# ORM과 JPA 연관관계, 그리고 N+1 문제 정리

---

## 1. ORM의 역할과 패러다임 불일치

- **객체지향 프로그래밍**과 **관계형 데이터베이스**는 모델링, 데이터 접근, 관계 표현 방식이 다름.
- ORM은 객체(Entity)와 테이블을 자동으로 매핑하고, 상태 동기화와 쿼리 추상화 등으로 개발 생산성과 유지보수를 높여줌.

| 구분      | 객체지향 프로그래밍         | 관계형 데이터베이스     |
|-----------|----------------------------|------------------------|
| 모델링     | 클래스, 상속, 다형성         | 테이블, 정규화          |
| 데이터 접근 | 메서드, 상태/행위 관리      | SQL, 트랜잭션           |
| 관계 표현  | 직접적 객체 참조            | 외래키, 조인            |

---

## 2. 연관관계의 종류

### 단방향 연관관계

- 한 쪽(예: Student)만 다른 쪽(예: School)을 참조
- 예시: `student.getSchool()`은 가능, `school.getStudent()`는 불가

### 양방향 연관관계

- 양쪽 모두 서로를 참조
- 예시: `student.getSchool()`, `school.getStudents()` 모두 가능
- 현실의 데이터베이스, 엑셀 시트 등에는 양방향 개념이 없지만, JPA에서는 라이브러리 차원에서 지원

---

## 3. JPA의 양방향 연관관계

- 실제 데이터베이스에는 양방향이 없고, JPA에서만 존재하는 개념
- JPA의 복잡성과 어려움의 상당 부분이 양방향 연관관계에서 비롯됨
- 실무에서는 **사이드 이펙트**(예상치 못한 데이터 변경, 순환 참조 등) 때문에 가급적 단방향을 권장
- `FetchType.LAZY`(지연 로딩)를 기본으로 사용하여, 불필요한 데이터 로딩과 부수효과를 방지

---

## 4. 실무에서 양방향을 지양하는 이유

- 장기적으로 유지보수와 디버깅이 어려워질 수 있음
- 트리거나 EAGER 로딩처럼, 명시적으로 코드로 통제되지 않는 부작용이 쌓이면 신규 인원 온보딩도 어려워짐
- 꼭 필요한 경우(부모-자식 라이프사이클이 완전히 일치)만 신중하게 사용

---

## 5. 연관관계 매핑의 복잡성 줄이기

- 불필요한 @OneToOne, @OneToMany, @ManyToMany 등 관계는 만들지 않도록 고민
- 단순한 구조로 설계하면 JPA 사용이 쉬워지고, 유지보수도 편해짐

---

## 6. N+1 문제와 해결법

- **N+1 문제**: 1개의 쿼리로 N개의 엔티티를 조회한 후, 각 엔티티마다 추가 쿼리가 N번 실행되는 현상
- **해결 방법**
    - Fetch Join: JPQL, QueryDSL 등에서 fetch join 사용
    - EntityGraph: JPA의 @EntityGraph로 연관 엔티티를 한 번에 로딩
    - DTO 프로젝션: 필요한 데이터만 DTO로 조회
    - BatchSize: @BatchSize 어노테이션 또는 설정 파일로 일괄 로딩
    - 쿼리 쪼개기: 여러 번의 쿼리로 필요한 데이터만 효율적으로 조회

---

## 7. 사고 넓히기

- 실제 데이터베이스 설계나 비즈니스 요구에 따라 연관관계를 아예 설정하지 못하는 경우도 있음
- 항상 비즈니스 목적과 팀의 합의를 우선시하며, 복잡한 설계나 패턴 도입은 신중하게 결정

---

> **TIP:**  
> JPA의 양방향 연관관계, Fetch 전략, N+1 문제 등은 실무에서 자주 마주치는 이슈입니다.  
> 단순한 설계와 명확한 책임 분리가 유지보수와 협업에 큰 도움이 됩니다!
